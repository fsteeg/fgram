<?xml version="1.0" encoding="UTF-8" ?><!-- Created from PDF via Acrobat SaveAsXML --><!-- Mapping Table version: 28-February-2003 --><TaggedPDF-doc><?xpacket begin='﻿' id='W5M0MpCehiHzreSzNTczkc9d'?><?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 4.0-c316 44.253921, Sun Oct 01 2006 17:08:23">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:xap="http://ns.adobe.com/xap/1.0/">
         <xap:CreateDate>2007-07-10T23:26:15+02:00</xap:CreateDate>
         <xap:CreatorTool>TeX</xap:CreatorTool>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:pdfx="http://ns.adobe.com/pdfx/1.3/">
         <pdfx:PTEX.Fullbanner>This is pdfeTeX, Version 3.141592-1.21a-2.2 (Web2C 7.5.4) kpathsea version 3.5.4</pdfx:PTEX.Fullbanner>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
         <pdf:Producer>pdfeTeX-1.21a</pdf:Producer>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:dc="http://purl.org/dc/elements/1.1/">
         <dc:format>xml</dc:format>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                           
<?xpacket end="w"?><?xpacket end='r'?><P>Paper for Advances in FDG based on a Poster presented at ICFG12 </P><P>Computational Representation of Underlying Structures and 
Lexical Entries using Domain-Speciﬁc Languages 
</P><P>Fabian Steeg, Christoph Benden, Paul O. Samuelsdorﬀ∗ </P><Part><H3>July 10, 2007 </H3><P>This paper describes a modular system for generating sentences from formal deﬁnitions of underlying structures and lexical entries represented using domain-speciﬁc languages. The system is implemented using Prolog, Java and the ANTLR parser generator. It could be used in the context of a larger NLP system and as a tool for formal notation in linguistic description in FG and FDG. </P><P>FDG ; NLP ; Parsing ; ANTLR ; DSL ; Java ; Prolog </P><Sect><H3>1 Motivation and Overview </H3><P>This paper describes a modular implementation of a system for generating sentences, using domain-speciﬁc languages (DSL; see section 3) for the formal representation of underlying structures and lexical entries. The DSL implemented for underlying structures is based on representations in Functional Grammar (FG; Dik 1997). Starting with a fully speciﬁed underlying structure instead of selecting lexical entries as the ﬁrst step corresponds to the shift of Functional Discourse Grammar (FDG) to a top-down organization (Hengeveld & Mackenzie 2006). Through its modular architecture the system can be extended for formal representations in FDG. The idea of creating a computational implementation of FG and FDG mechanisms, to “build a model of the natural language user” (Dik 1997, 1) is central to these frameworks and a valuable evaluation tool for linguistic theories in general, since “linguistics may learn from being applied” (Bakker 1994, 4). Therefore our </P><P>∗ </P><P>Department of Linguistics, University of Cologne, Germany, http://www.uni-koeln.de/phil-fak/iﬂ, fsteeg@spinfo.uni-koeln.de, cbenden@spinfo.uni-koeln.de, paul-o.samuelsdorﬀ@uni-koeln.de </P><Figure><ImageData src="Bilder/fdg-paper_img_0.jpg"/>d1x:'man'[N]:'happy'[A]Processing ModuleGrammar ModuleInputModuleDisplay ResultCreate InputProcess Prolog Repr.Generate Ling. Expr.Process InputProcess ResultThe happy man Access LexiconApply Expr. RulesProlog representation of the inputJavaJava,ANTLRProlog representation of the resultProlog</Figure><P>Figure 1: System Architecture </P><P>implementation can be used to evaluate and improve FDG with respect to theoretical issues in language generation. FDG demands “formal rigor” (Hengeveld & Mackenzie 2006, 668) and accordingly should be tested formally. Our implementation can therefore be used to evaluate and improve representational aspects of FDG. The expression rules and the lexicon are based on a revised and extended version of the implementation described in Samuelsdorﬀ (1989). By means of its modular architecture the program could act as the language generation component in a larger natural language processing (NLP) system or as a tool for formal notation in linguistic description. </P></Sect><Sect><H3>2 System Architecture </H3><P>The system consists of individual, exchangeable modules for creating an underlying structure, processing that input and generating a linguistic expression from the input (see </P><Figure><ImageData src="Bilder/fdg-paper_img_1.jpg"/></Figure><P>Figure 2: Screenshot of the console-based implementation 
</P><Figure><ImageData src="Bilder/fdg-paper_img_2.jpg"/></Figure><P>Figure 3: Screenshot of the Web-based implementation </P><P>Fig. 1). In the input module an underlying structure is created, edited and evaluated. Upon evaluation the input is sent to the processing module, which communicates with the grammar module. When the generation is done, the graphical user interface (GUI) displays either the result of the evaluation, namely the linguistic expression generated from the input, or an error message. The system architecture can be characterized as a Model-View-Controller (MVC) or three-tier architecture. Such a modular approach has two main advantages: First, modules can be exchanged; for instance the input module is implemented both as a console application (cf. Fig. 2) and as a web-based user interface with the actual processing happening on a server (implemented using Java Server Pages on a Tomcat servlet container, cf. Fig. 3). Second, by using a deﬁned input format, our system can be combined with other NLP components and be reused in new contexts. </P></Sect><Sect><H3>3 Domain-Speciﬁc Languages </H3><P>The usage of languages which are tailored for a speciﬁc domain (domain-speciﬁc languages, DSL) has a long tradition in computing and has been acknowledged as a best practice in </P><Figure><ImageData src="Bilder/fdg-paper_img_3.jpg"/>Input Parser ModuleDeﬁne GrammarGenerate ParserParse Input UCSJava APIANTLRProcessing Module&lt;&lt; uses &gt;&gt;EBNF</Figure><P>Figure 4: Parser overview 
</P><P>(Past e: (d1x:’man’[N]: </P><P>(Past Pf e:’give’[V] 
(d1x:’mary’[N])Ag 
(dmx:’book’[N]:’old’[A])Go 
(x:’man’[N])RecSubj 
</P><P>) 
) 
(d1x:’john’[N])0 
</P><P>) </P><P>Figure 5: A nested underlying structure based on Dik (1997), which is parsable by the generated ANTLRv2 parser (represents John is the man who was given the book by Mary) </P><P>recent years (cf. Hunt & Thomas 1999, Ch. 12 and Parr 2007). Our system uses Java as a general-purpose language, Prolog as a DSL for lexical entries and expression rules, and a self-deﬁned DSL for describing underlying structures, implemented using ANTLR, a tool for deﬁning and processing domain-speciﬁc languages (Parr 2007). While e.g. in the domain of banking a DSL might describe credit rules, a linguist working with a model like FDG uses a DSL for linguistic description, e.g. for formal notation of underlying structures. With ANTLR, the form of the DSL is deﬁned in EBNF notation (cf. Fig. 8), based on which a Java parser that can process the DSL is automatically generated, allowing for interaction with the abundant supply of libraries available in Java (cf. Fig. 4). </P><Figure><ImageData src="Bilder/fdg-paper_img_4.jpg"/>lexeme = givetense = past...Node x1:Predicatelexeme = farmermodif = old...Node x2:Termlexeme = ducklingmodif = soft...Node x3:Termlexeme = womanmodif = young...Node x4:Term</Figure><P>Figure 6: Internal representation of an underlying structure: a tree of Java objects (in UML notation) </P></Sect><Sect><H3>4 Underlying Structures </H3><P>The processing module’s input format is a representation of the linguistic expression to be generated; its form is based on the representation of underlying structures given in Dik (1997). The processing module parses the input entered by the user (or potentially coming from a diﬀerent source) and creates an internal representation (see Fig. 6) which is then converted into the output format of the processing module, a Prolog representation of the input, which is used by the grammar module. </P><P>Figures 5 and 7 show the structural similarity of underlying structures in FG and FDG; both representations are nested parentheses, which can also be represented as trees (cf. Fig. 6). Since these representations can be described and processed with the same mechanisms, and representations on all levels of FDG have a common scheme (Hengeveld & Mackenzie 2006, 671), support for FDG representations is easy to add by supplying ANTLR deﬁnitions for representations on the individual levels in FDG, like the Interpersonal Level (IL) and the Representational Level (RL, cf. Fig. 7, 8 and 9). Such an ANTLR grammar deﬁnition alone provides a validator for the formal structure of IL and RL representations. With grammar ﬁles for the IL and the RL implemented and having an internal representation of the input, alternative processing is possible too, e.g. output of typeset representations of the underlying structures with or without indentation. </P><P>(p1:[ (Past e1:[ </P><P>(f1:tek[ (x1:im(x1))Ag (x2:naif(x2))Inst </P><P>](f1)) </P><P>(f2:kot[ (x1:im(x1))Ag (x3:mi(x3))Pat </P><P>](f2)) ](e1)) ](p1)) </P><P>Figure 7: Underlying structure on the RL in FDG (Jamaican Creole: Im tek naif kot mi, ’He cut me with a knife’), which is parsable by the parser generated from the rules in Fig. 8 </P><Table><TR><TH>content </TH><TH>: </TH><TH>’(’ </TH><TH>OPERATOR? </TH><TH>’p’ </TH><TH>X </TH><TH>( </TH><TH>’:’ </TH><TH>head </TH><TH>’(’ ’p’ </TH><TH>X </TH><TH>’)’ )* ’)’ </TH><TH>FUNCTION? </TH><TH>; </TH></TR><TR><TD>soa </TD><TD>: </TD><TD>’(’ </TD><TD>OPERATOR? </TD><TD>’e’ </TD><TD>X </TD><TD>( </TD><TD>’:’ </TD><TD>head </TD><TD>’(’ </TD><TD>’e’ </TD><TD>X </TD><TD>’)’ )* ’)’ </TD><TD>FUNCTION? </TD><TD>; </TD></TR><TR><TD>property </TD><TD>: </TD><TD>’(’ </TD><TD>OPERATOR? </TD><TD>’f’ </TD><TD>X </TD><TD>( </TD><TD>’:’ </TD><TD>head </TD><TD>’(’ </TD><TD>’f’ </TD><TD>X </TD><TD>’)’ )* ’)’ </TD><TD>FUNCTION? </TD><TD>; </TD></TR><TR><TD>individual </TD><TD>: </TD><TD>’(’ </TD><TD>OPERATOR? </TD><TD>’x’ </TD><TD>X </TD><TD>( </TD><TD>’:’ </TD><TD>head </TD><TD>’(’ </TD><TD>’x’ </TD><TD>X </TD><TD>’)’ )* ’)’ </TD><TD>FUNCTION? </TD><TD>; </TD></TR><TR><TD>location </TD><TD>: </TD><TD>’(’ </TD><TD>OPERATOR? </TD><TD>’l’ </TD><TD>X </TD><TD>( </TD><TD>’:’ </TD><TD>head </TD><TD>’(’ </TD><TD>’l’ </TD><TD>X </TD><TD>’)’ )* ’)’ </TD><TD>FUNCTION? </TD><TD>; </TD></TR><TR><TD>time </TD><TD>: </TD><TD>’(’ </TD><TD>OPERATOR? </TD><TD>’t’ </TD><TD>X </TD><TD>( </TD><TD>’:’ </TD><TD>head </TD><TD>’(’ </TD><TD>’t’ </TD><TD>X </TD><TD>’)’ )* ’)’ </TD><TD>FUNCTION? </TD><TD>; </TD></TR><TR><TD>head </TD><TD>: </TD><TD>LEMMA? </TD><TD>( ’[’ </TD><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/></TR><TR><TD/><TD>( </TD><TD>soa </TD><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/></TR><TR><TD/><TD>| property </TD><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/></TR><TR><TD/><TD>| </TD><TD>individual </TD><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/></TR><TR><TD/><TD>| </TD><TD>location </TD><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/></TR><TR><TD/><TD>| </TD><TD>time </TD><TD>)* ’]’ ) </TD><TD>? </TD><TD>; </TD><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/></TR></Table><P>Figure 8: ANTLR v3 parser rules for structures on the RL 
</P><Figure><ImageData src="Bilder/fdg-paper_img_5.jpg"/></Figure><P>Figure 9: Part of the parse tree for the expression in Fig. 7 
</P><P>verb( give, action, [gave, given], [ </P><P>[agent, animate, X1], 
[goal, any, X2], 
[recipient, animate, X3] 
</P><P>], Sat ). </P><P>Figure 10: Ditransitive verb as a Prolog fact in the lexicon </P></Sect><Sect><H3>5 Lexical Entries </H3><P>In the grammar module the Prolog representation of the input generated by the processing module is used to generate a linguistic expression. Prolog was developed as a programming language for linguists and therefore oﬀers convenient notation and processing mechanisms, </P><P>e.g. lexical entries can be stored directly as Prolog facts (see Fig. 10). Prolog also has a particular strong standing as an implementation language for FG (e.g. Samuelsdorﬀ 1989; Dik 1992). By restricting the usage of Prolog to lexical entries and expression rules and combining it with other languages, instead of using it as a general-purpose programming language for the entire program, we use Prolog as a DSL in its original domain. The expression rules and the lexicon are based on a revised and extended version of the implementation described in Samuelsdorﬀ (1989). To make the implementation work as a module in the described system, the user dialog of the original version (in which the underlying structure is built step by step) was replaced by an immediate processing of the entire input representing the linguistic expression to be generated. The user dialog is therefore replaced by the formal representation, which is created in the input module and converted into a Prolog representation by the processing module. This resembles the shift to a top-down organization in FDG (Hengeveld & Mackenzie 2006), where the conceptualization is the ﬁrst step, not the selection of lexical elements, as it was in FG and in our original implementation. </P></Sect><Sect><H3>6 Conclusion </H3><P>We described a modular implementation of a language generation system, representing underlying structures and lexical entries using domain-speciﬁc languages. The system makes use of an input format based on Dik (1997) and consists of modules implemented in Java, Prolog and ANTLR, making it easy to extend for FDG representations. As all structures used in FDG as well as the lexical entries as Prolog facts have a common tree structure, a uniﬁed implementation using ANTLR to deﬁne and process all these structures is feasible and would allow further processing in all the target languages supported by ANTLR (currently Java, C, C++, C#, Objective-C, Python and Ruby). The system can be used to evaluate and improve FDG with respect to theoretical and representational issues; by means of its modular architecture it could act as the language generation component in a larger NLP system or as a tool for formal notation in linguistic description. The implementation and infrastructure for collaborative development is available at http://fgram.sourceforge.net. </P></Sect><Sect><H3>References </H3><P>Bakker, D.: 1994, Formal and Computational Aspects of Functional Grammar and Language Typology, Ph.D. thesis, Universiteit van Amsterdam. </P><P>Dik, S. C.: 1992, Functional Grammar in Prolog: an Integrated Implementation for English, French and Dutch, Mouton de Gruyter, Berlin, New York. </P><P>Dik, S. C.: 1997, The Theory of Functional Grammar. Part 1: The Structure of the Clause (edited by Kees Hengeveld), second edn., Mouton de Gruyter, Berlin. </P><P>Hengeveld, K. & L. J. Mackenzie: 2006, ‘Functional Discourse Grammar’, in </P><P>K. Brown (ed.), Encyclopedia of Language and Linguistics, second edn., Elsevier, Oxford, pp. 668–676. </P><P>Hunt, A. & D. Thomas: 1999, The Pragmatic Programmer: From Journeyman to Master, Addison-Wesley Professional. </P><P>Parr, T.: 2007, The Deﬁnitive ANTLR Reference: Building Domain-Speciﬁc Languages, The Pragmatic Bookshelf, Raleigh. </P><P>Samuelsdorff, P. O.: 1989, ‘Simulation of a Functional Grammar in Prolog’, in J. H. Connolly & S. C. Dik (eds.), Functional Grammar and the Computer, De Gruyter, pp. 29–44. </P></Sect></Part></TaggedPDF-doc>